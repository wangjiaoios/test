##第五天 + 第六天
###我的界面完成
显示的两种做法
1. 三个cell显示，最后一个cell比较长
2. 两个cell显示，最后一个为tableView的tablefootView

如果cell中image图片提供的比较大，我们可以通过自定义cell，然后重写layoutSubviews 来调整imageView的大小

当cell内子控件特别多的时候就需要完全自定义cell

cell加载的时候通过通过调用 initwithStyle 而不是initformNib方法，因为cell需要重用



### CocoaPods
- Podfile.lock文件
    - 最后一次更新Pods时, 所有第三方框架的版本号
- 常用指令的区别
    - pod install
        - 会根据Podfile.lock文件中列举的版本号来安装第三方框架
        - 如果一开始Podfile.lock文件不存在, 就会按照Podfile文件列举的版本号来安装第三方框架
        - 安装框架之前, 默认会执行pod repo update指令
    - pod update
        - 将所有第三方框架更新到最新版本, 并且创建一个新的Podfile.lock文件
        - 安装框架之前, 默认会执行pod repo update指令
    - pod install --no-repo-update
    - pod update --no-repo-update
        - 安装框架之前, 不会执行pod repo update指令

### 利用SDWebImage设置UIButton的图片
- 正确用法

```
[button sd_setImageWithURL:[NSURL URLWithString:url] forState:UIControlStateNormal placeholderImage:image];
```

### 自定义footView
button超出父控件的按钮是没有办法点击的
为什么footView的宽度有值，但是高度没有值 ，过完一段时间再拿frame肯定是有值的。

因为我们在外面使用的是alloc init创建的，所以传入的frame为0.

footview 的宽度默认就是填充屏幕的

### 拿到button对应的url的方法
1. 使用字典，创建button和模型的一对一字典，在点击方法中拿到 。可以使用button.description来作为key，如果模型中name名字不一样的话 也可以使用name 
2. 给button绑定模型，即给button添加一个模型对象，创建button的时候将模型赋值给对象，这样在点击方法中也可以轻易拿到模型取出url

### 计算行数


###计算文件大小

沙盒 
tmp 临时存在
documents 固定的，但是不允许放比较大的文件，因为里面你的东西会被备份,不能下载东西在这里
library  caches preference 
清除缓存的文件 只要清除 caches 里面default(default是sd产生的文件) ,或者自己创建的文件 如MP3 MP4 。

获取文件的大小 相当于获取文件内所有文件的大小然后相加
contents  
subpaths

sd里面也有一个办法用来获得文件大小 

directoryEnumerator  遍历器，迭代器， 相当于数组，利用for in 循环从中取出字符串。

### 封装计算文件大小

给nsstring增加分类

需要判断是文件还是文件夹
1.  filetype  取出nsfilrtype对应的值，判断是否是文件夹 
2.  manager 

计算缓存大小如果文件太大会卡主主线程，所以我们一般放到子线程中去执行 


###accessoryView 优先级高于 accessoryType 当两个同时设置的时候，View显示

自定义cell  创建cell的同时 内部会执行initwithstyle方法


### 点击清除 
将文件夹里面的东西全部给删掉，删除是不可逆的


1. 可以给cell添加手势，将清除按钮也封装到cell内部，添加手势以后 会拦截代理方法 
2.  使用代理方法



### 清除缓存
sd 清除文件在子线程执行
我们自己的文件清除也需要在子线程执行

所以需要等所有文件都删除以后，在创建文件 然后在回到主线程执行操作

### 不同类型的cell共存

当一个cell是特有的，与其他cell不一样，业务逻辑也被独立的封装起来，为了避免复杂重复的操作，这种cell最好独立出来，最好不要循环给别的cell，明显没办法循环利用的cell 要独立出来。

怎么独立出来
用两种独立类型的cell
两个标识，使用不同的标识

注册很关键，一种标识就对应一种cell 	通过一种标识来找一种cell的时候 如果没有创建创建一个cell  ,通过另外一种标识来找cell 的时候 就会创建另外一种cell 

多种不同的cell  多种不同的cell 对应多种不同的标识 。

### cell 的销毁时刻
美团例子 
中间的东西都一样，
最后一块可以用一个footView 
上面的 可以是cell 也可是一个heardView

当进入控制器，正在计算时，返回，控制器已经被销毁。
cell  会等子线程任务执行完毕之后 才会被销毁，之前因为还要用到cell  block中引用了一些强引用对象，所以不会让cell死

cell 早一点释放 使用弱引用
typeof(20);看20是什么类型 20是int类型
age也是int 类型
typeof(20) age = 10; 

block内部会自动产生一个强引用，引用那个对象，不让其释放，只要blcok在，对象就会在


为什么，如果block内部如果用弱引用 引用外面对象的时候，block内部就不会对那个对象产生强引用。其该释放的时候就会被释放

虽然已经释放 但是代码还是会往下面执行，对象就会为空 弱引用的对象如果释放了，对象就会被至为空。

assasin 还是会指向那块地址	，容易造成僵尸指针。


### 每当cell重新显示到屏幕上时，都会调用一次layoutsubviews

###精华新帖按钮
基本框架 viewController 上面有 放一个scrollerView 和 uiview 

scrollerView 上面放五个tableView 
uiview上面放五个标题



### 五个标题的view
 
如果button不想要高亮状态，重写sethightlight方法即可
底部指示器设置

### 添加子控制器的view

### 懒加载子控制器的view

我们之前的做法是 一进界面5个子控制器的view就创建好了，并且cell也都展示了，我们现在看不到的界面也都被创建了，这显然占用了大量的内存，是没有必要的

刚开始只加载第一个界面控制器
懒加载方法，当点击上方标题时，先滚动到该界面显示的区域，然后在加载那个界面

scrollView 代理方法

滑动结束时

didEndDecelerating  人手动滑动时，滑动停止 调用
didEndScrollingAnimation  一定要调用[setcontentoffset animated ] 或者 [scrollerRactVisible animaated]方法让scroll产生滚动动画，动画结束时才会调用 

viewWithTag：会检查自己和自己所有子控件有没有tag等于值，如果还没有 就查找子控件的子控件。

先看自己 然后看自己的子控件 ，然后看子控件的子控件。

默认情况下所有控件的tag都是0 

## viewWithTag:内部的大致实现思路
```
@implementation UIView
- (UIView *)viewWithTag:(NSInteger)tag
{
    if (self.tag == tag) return self;

    for (UIView *subview in self.subviews) {
        return [subview viewWithTag:tag];
    }
}
@end
```


### 疑惑，手指滑动为什么没有子控制器VIEW

必须产生滚动动画才可以，当手指滑动的时候 虽然调用了[setcontentoffset animated ] 方法，但是偏移量是没有改变的 所有就没有产生动画，既然没有产生动画，所以不会调用那个方法




